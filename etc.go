package assert

import (
	"fmt"
	"reflect"
	"runtime"
	"strings"
)

type TestingT interface {
	Errorf(format string, args ...interface{})
}

func fail(t TestingT, actual, expected interface{}, failureMessage string) {
	// like gtest
	diffstr := fmt.Sprintf("\n"+
		"Actual  : %v\n"+
		"Expected: %v\n", actual, expected)

	t.Errorf("\n\033[31m[FAIL] %s\n%s%v\033[39m\n", callerInfo(), failureMessage, diffstr)
}

func objectsAreEqual(actual, expected interface{}) bool {
	if actual == nil || expected == nil {
		return actual == expected
	}

	return reflect.DeepEqual(actual, expected)
}

func formatUnequalValues(actual, expected interface{}) (e string, a string) {
	if reflect.TypeOf(expected) != reflect.TypeOf(actual) {
		return fmt.Sprintf("%T(%#v)", actual, actual),
			fmt.Sprintf("%T(%#v)", expected, expected)
	}

	return fmt.Sprintf("%#v", actual),
		fmt.Sprintf("%#v", expected)
}

func callerInfo() string {
	pc := uintptr(0)
	file := ""
	line := 0
	ok := false
	name := ""

	callers := ""
	for i := 0; ; i++ {
		pc, file, line, ok = runtime.Caller(i)
		if !ok {
			// The breaks below failed to terminate the loop, and we ran off the
			// end of the call stack.
			break
		}

		// This is a huge edge case, but it will panic if this is the case, see #180
		if file == "<autogenerated>" {
			break
		}

		f := runtime.FuncForPC(pc)
		if f == nil {
			break
		}
		name = f.Name()

		// testing.tRunner is the standard library function that calls
		// tests. Subtests are called directly by tRunner, without going through
		// the Test/Benchmark/Example function that contains the t.Run calls, so
		// with subtests we should break when we hit tRunner, without adding it
		// to the list of callers.
		if name == "testing.tRunner" {
			break
		}

		parts := strings.Split(file, "/")
		dir := parts[len(parts)-2]
		file = parts[len(parts)-1]
		if dir != "assert" {
			callers = fmt.Sprintf("%s:%d", file, line)
			return callers
		}
	}

	return callers
}

func isNil(object interface{}) bool {
	if object == nil {
		return true
	}

	value := reflect.ValueOf(object)
	kind := value.Kind()
	if kind >= reflect.Chan && kind <= reflect.Slice && value.IsNil() {
		return true
	}

	return false
}

func getLen(x interface{}) (ok bool, length int) {
	v := reflect.ValueOf(x)
	defer func() {
		if e := recover(); e != nil {
			ok = false
		}
	}()
	return true, v.Len()
}

func includeElement(list interface{}, element interface{}) (ok, found bool) {

	listValue := reflect.ValueOf(list)
	elementValue := reflect.ValueOf(element)
	defer func() {
		if e := recover(); e != nil {
			ok = false
			found = false
		}
	}()

	if reflect.TypeOf(list).Kind() == reflect.String {
		return true, strings.Contains(listValue.String(), elementValue.String())
	}

	if reflect.TypeOf(list).Kind() == reflect.Map {
		mapKeys := listValue.MapKeys()
		for i := 0; i < len(mapKeys); i++ {
			if objectsAreEqual(mapKeys[i].Interface(), element) {
				return true, true
			}
		}
		return true, false
	}

	for i := 0; i < listValue.Len(); i++ {
		if objectsAreEqual(listValue.Index(i).Interface(), element) {
			return true, true
		}
	}
	return true, false
}

func isNumbericType(object interface{}) bool {
	t := reflect.TypeOf(object).Kind()

	switch t {
	case reflect.Int,
		reflect.Int8,
		reflect.Int16,
		reflect.Int32,
		reflect.Int64,
		reflect.Uint,
		reflect.Uint8,
		reflect.Uint16,
		reflect.Uint32,
		reflect.Uint64,
		reflect.Float32,
		reflect.Float64,
		reflect.Complex64,
		reflect.Complex128:

		return true

	default:
		return false
	}
}
